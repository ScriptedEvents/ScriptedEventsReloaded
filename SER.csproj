<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net48</TargetFramework>
        <OutputType>Library</OutputType>
        <RootNamespace>SER</RootNamespace>
        <AssemblyName>SER</AssemblyName>
        <Nullable>enable</Nullable>
        <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
        <LangVersion>preview</LangVersion>
        <PlatformTarget>x64</PlatformTarget>
        <ImplicitUsings>enable</ImplicitUsings>
        <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
        <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
        <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
    </PropertyGroup>

    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
        <DebugSymbols>true</DebugSymbols>
        <DebugType>embedded</DebugType>
        <Optimize>false</Optimize>
        <DefineConstants>DEBUG;TRACE;HAVE_NULLABLE_ATTRIBUTES</DefineConstants>
        <OutputPath>bin\Debug\</OutputPath>
        <WarningLevel>4</WarningLevel>
    </PropertyGroup>

    <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
        <DebugType>full</DebugType>
        <Optimize>true</Optimize>
        <DefineConstants>TRACE;HAVE_NULLABLE_ATTRIBUTES</DefineConstants>
        <OutputPath>bin\Release\</OutputPath>
        <WarningLevel>4</WarningLevel>
    </PropertyGroup>

    <ItemGroup>
        <Reference Include="0Harmony">
            <HintPath>$(SL_DEV_REFERENCES)\0Harmony.dll</HintPath>
        </Reference>
        <Reference Include="Assembly-CSharp">
            <HintPath>$(SL_DEV_REFERENCES)\Assembly-CSharp.dll</HintPath>
        </Reference>
        <Reference Include="Assembly-CSharp-firstpass">
            <HintPath>$(SL_DEV_REFERENCES)\Assembly-CSharp-firstpass.dll</HintPath>
        </Reference>
        <Reference Include="CommandSystem.Core">
            <HintPath>$(SL_DEV_REFERENCES)\CommandSystem.Core.dll</HintPath>
            <Private>true</Private>
        </Reference>
        <Reference Include="Mirror">
            <HintPath>$(SL_DEV_REFERENCES)\Mirror.dll</HintPath>
        </Reference>
        <Reference Include="Pooling">
            <HintPath>$(SL_DEV_REFERENCES)\Pooling.dll</HintPath>
        </Reference>
        <Reference Include="UnityEngine">
            <HintPath>$(SL_DEV_REFERENCES)\UnityEngine.dll</HintPath>
        </Reference>
        <Reference Include="UnityEngine.CoreModule">
            <HintPath>$(SL_DEV_REFERENCES)\UnityEngine.CoreModule.dll</HintPath>
        </Reference>
        <Reference Include="UnityEngine.PhysicsModule">
            <HintPath>$(SL_DEV_REFERENCES)\UnityEngine.PhysicsModule.dll</HintPath>
        </Reference>
        <Reference Include="UnityEngine.UnityWebRequestModule">
            <HintPath>$(SL_DEV_REFERENCES)\UnityEngine.UnityWebRequestModule.dll</HintPath>
        </Reference>
    </ItemGroup>
    
    <!-- QoL moving the dll -->
    <Target Name="PostBuild" AfterTargets="PostBuildEvent">
        <Copy SourceFiles="$(TargetDir)SER.dll" DestinationFolder="$(LABAPI_PLUGINS)" />
        <Copy SourceFiles="$(TargetDir)SER.dll" DestinationFolder="$(SL_DEV_REFERENCES)" />
    </Target>

    <ItemGroup>
        <None Include="App.config" />
        <None Include="packages.config" />
        <Content Include=".gitignore" />
        <Content Include="README.md" />
        <None Include="THIRD_PARTY_LICENSES.txt" CopyToOutputDirectory="Always" />
    </ItemGroup>

    <!-- ignore warnings about mismatch between versions of core libs
        and unreachable code because compiler is stupid -->
    <PropertyGroup>
        <NoWarn>$(NoWarn);MSB3277;CS0162</NoWarn>
    </PropertyGroup>

    <!-- nuget refs -->
    <ItemGroup>
        <PackageReference Include="AudioPlayerApi" Version="1.1.2" />
        <PackageReference Include="ExMod.Exiled" Version="9.12.5" />
        <PackageReference Include="NCalc" Version="1.3.8" />
        <PackageReference Include="Newtonsoft.Json" Version="13.0.4" />
        <PackageReference Include="Northwood.LabAPI" Version="1.1.5" />
        <PackageReference Include="PolySharp" Version="1.15.0">
          <PrivateAssets>all</PrivateAssets>
          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
    <ItemGroup>
      <Folder Include="Code\" />
      <Folder Include="Code\MethodSystem\Methods\EXILED_custom_roleMethods\" />
    </ItemGroup>

    <!-- embedding dependencies into SER.dll -->
    <Target Name="EmbedSelectedDependencies" AfterTargets="ResolveReferences">
        <ItemGroup>
            <EmbeddedResource Include="@(ReferenceCopyLocalPaths)"
                              Condition="'%(Extension)' == '.dll' and
                                 (
                                   '%(ReferenceCopyLocalPaths.NuGetPackageId)' == 'NCalc' or
                                   
                                   '%(ReferenceCopyLocalPaths.NuGetPackageId)' == 'Newtonsoft.Json' or
                                   
                                   '%(ReferenceCopyLocalPaths.NuGetPackageId)' == 'AudioPlayerApi' or
                                   '%(Filename)' == 'NVorbis' or
                                   '%(Filename)' == 'SharpCompress'
                                 )" />
        </ItemGroup>
    </Target>
    
    <!-- this checkes if the script examples are able to be compiled -->
    <UsingTask TaskName="RunDllValidation" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
        <ParameterGroup>
            <AssemblyPath ParameterType="System.String" Required="true" />
            <ReferencePath ParameterType="System.String" Required="true" />
        </ParameterGroup>
        <Task>
            <Using Namespace="System" />
            <Using Namespace="System.IO" />
            <Using Namespace="System.Reflection" />
            <Code Type="Fragment" Language="cs">
                <![CDATA[
          #nullable enable annotations
          // 1. Resolver for SCP:SL Dependencies
          ResolveEventHandler resolver = (sender, args) => {
              try {
                  // Parse the requested assembly name
                  var nameObj = new AssemblyName(args.Name);
                  string fileName = nameObj.Name + ".dll";
                  
                  // Look in the game references folder
                  string fullPath = Path.Combine(ReferencePath, fileName);
                  
                  if (File.Exists(fullPath)) {
                      return Assembly.LoadFrom(fullPath);
                  }
              }
              catch (Exception e)
              {
                  Log.LogError("Resolver Error: " + e.ToString());
              }

              return null;
          };

        try
        {
          AppDomain.CurrentDomain.AssemblyResolve += resolver;

              if (!File.Exists(AssemblyPath)) {
                  Log.LogError("Target DLL not found: " + AssemblyPath);
                  return false;
              }

              // 3. Load the DLL
              // LoadFrom allows dependencies to be resolved via the event handler
              Assembly assembly = Assembly.LoadFrom(AssemblyPath);
              
              {
                  // 4. Find the class (Namespace.ClassName)
                  Type? targetType = assembly.GetType("SER.Code.MethodSystem.MethodIndex");
                  if (targetType == null) 
                  {
                      Log.LogError("Validation Error: Type 'SER.Code.MethodSystem.MethodIndex' not found.");
                      return false;
                  }
    
                  // 5. Find the method
                MethodInfo? method = targetType.GetMethod(
                    "AddAllDefinedMethodsInAssembly",
                    BindingFlags.Public | BindingFlags.Static
                );
                  if (method == null)
                  {
                      Log.LogError("Validation Error: Static method 'AddAllDefinedMethodsInAssembly()' not found.");
                      return false;
                  }
   
                  method.Invoke(null, new object[] { assembly });
                  Log.LogMessage(MessageImportance.High, ">>> Loaded methods.");
              }
              
              {
                  // 4. Find the class (Namespace.ClassName)
                  Type? targetType = assembly.GetType("SER.Code.Examples.Example");
                  if (targetType == null) 
                  {
                      Log.LogError("Validation Error: Type 'SER.Code.Examples.Example' not found.");
                      return false;
                  }
    
                  // 5. Find the method
                MethodInfo? method = targetType.GetMethod(
                    "Verify",
                    BindingFlags.Public | BindingFlags.Static
                );
                  if (method == null)
                  {
                      Log.LogError("Validation Error: Static method 'Verify()' not found.");
                      return false;
                  }
    
                  Log.LogMessage(MessageImportance.High, ">>> Validating Scripts...");
    
                  // 6. Invoke
                  string result = (string)method.Invoke(null, null);
    
                  if (!string.IsNullOrEmpty(result))
                  {
                      Log.LogError("SCRIPT ERROR: " + result);
                      return false;
                  }
    
                  Log.LogMessage(MessageImportance.High, ">>> Validation Passed.");
                  return true;
              }
          }
          catch (OperationCanceledException)
          {
              throw;
          }
          catch (ReflectionTypeLoadException re)
          {
              foreach (var loaderEx in re.LoaderExceptions)
              {
                  Log.LogError("Loader Error: " + loaderEx.ToString());
              }
              return false;
          }
          catch (TargetInvocationException tie)
          {
              Log.LogError("Invocation Error: " +
                  (tie.InnerException != null ? tie.InnerException.ToString() : tie.ToString()));
              return false;
          }
          catch (Exception ex) 
          {
              Log.LogError("Task Error: " + ex.ToString());
              return false;
          }
          finally {
              // 7. Detach Resolver to keep build process clean
              AppDomain.CurrentDomain.AssemblyResolve -= resolver;
          }
          #nullable disable annotations
        ]]>
            </Code>
        </Task>
    </UsingTask>

    <Target Name="RunValidation" AfterTargets="Build">
        <RunDllValidation AssemblyPath="$(TargetPath)" ReferencePath="$(SL_DEV_REFERENCES)" />
    </Target>
</Project>
